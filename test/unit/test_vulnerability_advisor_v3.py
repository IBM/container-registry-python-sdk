# -*- coding: utf-8 -*-
# (C) Copyright IBM Corp. 2021.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Unit Tests for VulnerabilityAdvisorV3
"""

from ibm_cloud_sdk_core.authenticators.no_auth_authenticator import NoAuthAuthenticator
import inspect
import json
import pytest
import re
import requests
import responses
import urllib
from ibm_container_registry.vulnerability_advisor_v3 import *

account = 'testString'
accept_language = 'testString'

service = VulnerabilityAdvisorV3(
    authenticator=NoAuthAuthenticator(),
    account=account
    )

base_url = 'https://us.icr.io'
service.set_service_url(base_url)

##############################################################################
# Start of Service: Report
##############################################################################
# region

class TestAccountReportQueryPath():
    """
    Test Class for account_report_query_path
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_account_report_query_path_all_params(self):
        """
        account_report_query_path()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account')
        mock_response = '{"assessments": {"mapKey": {"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        repository = 'testString'
        include_ibm = 'testString'
        include_private = 'testString'

        # Invoke method
        response = service.account_report_query_path(
            repository=repository,
            include_ibm=include_ibm,
            include_private=include_private,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?',1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'repository={}'.format(repository) in query_string
        assert 'includeIBM={}'.format(include_ibm) in query_string
        assert 'includePrivate={}'.format(include_private) in query_string


    @responses.activate
    def test_account_report_query_path_required_params(self):
        """
        test_account_report_query_path_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account')
        mock_response = '{"assessments": {"mapKey": {"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.account_report_query_path()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_account_report_query_path_value_error(self):
        """
        test_account_report_query_path_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account')
        mock_response = '{"assessments": {"mapKey": {"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.account_report_query_path(**req_copy)



class TestAccountStatusQueryPath():
    """
    Test Class for account_status_query_path
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_account_status_query_path_all_params(self):
        """
        account_status_query_path()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account/status')
        mock_response = '{"images": [{"configuration_issue_count": 25, "created_time": 12, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "name": "name", "scan_time": 9, "status": "status", "vulnerability_count": 19}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        repository = 'testString'
        include_ibm = 'testString'
        include_private = 'testString'

        # Invoke method
        response = service.account_status_query_path(
            repository=repository,
            include_ibm=include_ibm,
            include_private=include_private,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?',1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'repository={}'.format(repository) in query_string
        assert 'includeIBM={}'.format(include_ibm) in query_string
        assert 'includePrivate={}'.format(include_private) in query_string


    @responses.activate
    def test_account_status_query_path_required_params(self):
        """
        test_account_status_query_path_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account/status')
        mock_response = '{"images": [{"configuration_issue_count": 25, "created_time": 12, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "name": "name", "scan_time": 9, "status": "status", "vulnerability_count": 19}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.account_status_query_path()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_account_status_query_path_value_error(self):
        """
        test_account_status_query_path_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/account/status')
        mock_response = '{"images": [{"configuration_issue_count": 25, "created_time": 12, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "name": "name", "scan_time": 9, "status": "status", "vulnerability_count": 19}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.account_status_query_path(**req_copy)



class TestImageReportQueryPath():
    """
    Test Class for image_report_query_path
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_image_report_query_path_all_params(self):
        """
        image_report_query_path()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/testString')
        mock_response = '{"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Invoke method
        response = service.image_report_query_path(
            name,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_image_report_query_path_required_params(self):
        """
        test_image_report_query_path_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/testString')
        mock_response = '{"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Invoke method
        response = service.image_report_query_path(
            name,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_image_report_query_path_value_error(self):
        """
        test_image_report_query_path_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/testString')
        mock_response = '{"configuration_issues": [{"corrective_action": "corrective_action", "description": "description", "exempt": true, "meta": {"mapKey": "inner"}, "type": "type"}], "id": "id", "scan_time": 9, "status": "status", "vulnerabilities": [{"cve_exempt": true, "cve_id": "cve_id", "exempt_security_notice_count": 28, "exempt_status": "exempt_status", "security_notice_count": 21, "security_notices": [{"notice": "notice", "notice_exempt": false, "notice_id": "notice_id", "summary": "summary", "vulnerable_packages": [{"corrective_action": "corrective_action", "description": "description", "fix_version": "fix_version", "installed_version": "installed_version", "package_name": "package_name"}]}], "summary": "summary", "total_security_notice_count": 27}]}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "name": name,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.image_report_query_path(**req_copy)



class TestImageStatusQueryPath():
    """
    Test Class for image_status_query_path
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_image_status_query_path_all_params(self):
        """
        image_status_query_path()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/status/testString')
        mock_response = '{"configuration_issue_count": 25, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "scan_time": 9, "status": "status", "vulnerability_count": 19}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Invoke method
        response = service.image_status_query_path(
            name,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_image_status_query_path_required_params(self):
        """
        test_image_status_query_path_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/status/testString')
        mock_response = '{"configuration_issue_count": 25, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "scan_time": 9, "status": "status", "vulnerability_count": 19}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Invoke method
        response = service.image_status_query_path(
            name,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_image_status_query_path_value_error(self):
        """
        test_image_status_query_path_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/report/image/status/testString')
        mock_response = '{"configuration_issue_count": 25, "exempt_configuration_issue_count": 32, "exempt_issue_count": 18, "exempt_vulnerability_count": 26, "issue_count": 11, "scan_time": 9, "status": "status", "vulnerability_count": 19}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        name = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "name": name,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.image_status_query_path(**req_copy)



# endregion
##############################################################################
# End of Service: Report
##############################################################################

##############################################################################
# Start of Service: Exemption
##############################################################################
# region

class TestListExemptionAccount():
    """
    Test Class for list_exemption_account
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_list_exemption_account_all_params(self):
        """
        list_exemption_account()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.list_exemption_account()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_exemption_account_required_params(self):
        """
        test_list_exemption_account_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.list_exemption_account()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_exemption_account_value_error(self):
        """
        test_list_exemption_account_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.list_exemption_account(**req_copy)



class TestGetExemptionAccount():
    """
    Test Class for get_exemption_account
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_get_exemption_account_all_params(self):
        """
        get_exemption_account()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.get_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_get_exemption_account_required_params(self):
        """
        test_get_exemption_account_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.get_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_get_exemption_account_value_error(self):
        """
        test_get_exemption_account_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.get_exemption_account(**req_copy)



class TestCreateExemptionAccount():
    """
    Test Class for create_exemption_account
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_create_exemption_account_all_params(self):
        """
        create_exemption_account()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.create_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201


    @responses.activate
    def test_create_exemption_account_required_params(self):
        """
        test_create_exemption_account_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.create_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201


    @responses.activate
    def test_create_exemption_account_value_error(self):
        """
        test_create_exemption_account_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.create_exemption_account(**req_copy)



class TestDeleteExemptionAccount():
    """
    Test Class for delete_exemption_account
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_delete_exemption_account_all_params(self):
        """
        delete_exemption_account()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.delete_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_delete_exemption_account_required_params(self):
        """
        test_delete_exemption_account_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.delete_exemption_account(
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_delete_exemption_account_value_error(self):
        """
        test_delete_exemption_account_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.delete_exemption_account(**req_copy)



class TestListExemptionResource():
    """
    Test Class for list_exemption_resource
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_list_exemption_resource_all_params(self):
        """
        list_exemption_resource()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'

        # Invoke method
        response = service.list_exemption_resource(
            resource,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_exemption_resource_required_params(self):
        """
        test_list_exemption_resource_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'

        # Invoke method
        response = service.list_exemption_resource(
            resource,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_exemption_resource_value_error(self):
        """
        test_list_exemption_resource_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "resource": resource,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.list_exemption_resource(**req_copy)



class TestGetExemptionResource():
    """
    Test Class for get_exemption_resource
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_get_exemption_resource_all_params(self):
        """
        get_exemption_resource()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.get_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_get_exemption_resource_required_params(self):
        """
        test_get_exemption_resource_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.get_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_get_exemption_resource_value_error(self):
        """
        test_get_exemption_resource_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "resource": resource,
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.get_exemption_resource(**req_copy)



class TestCreateExemptionResource():
    """
    Test Class for create_exemption_resource
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_create_exemption_resource_all_params(self):
        """
        create_exemption_resource()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.create_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201


    @responses.activate
    def test_create_exemption_resource_required_params(self):
        """
        test_create_exemption_resource_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.create_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201


    @responses.activate
    def test_create_exemption_resource_value_error(self):
        """
        test_create_exemption_resource_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        mock_response = '{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=201)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "resource": resource,
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.create_exemption_resource(**req_copy)



class TestDeleteExemptionResource():
    """
    Test Class for delete_exemption_resource
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_delete_exemption_resource_all_params(self):
        """
        delete_exemption_resource()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.delete_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_delete_exemption_resource_required_params(self):
        """
        test_delete_exemption_resource_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Invoke method
        response = service.delete_exemption_resource(
            resource,
            issue_type,
            issue_id,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_delete_exemption_resource_value_error(self):
        """
        test_delete_exemption_resource_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/image/testString/issue/testString/testString')
        responses.add(responses.DELETE,
                      url,
                      status=200)

        # Set up parameter values
        resource = 'testString'
        issue_type = 'testString'
        issue_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "resource": resource,
            "issue_type": issue_type,
            "issue_id": issue_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.delete_exemption_resource(**req_copy)



class TestExemptHandler():
    """
    Test Class for exempt_handler
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_exempt_handler_all_params(self):
        """
        exempt_handler()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/types')
        mock_response = '[{"display_name": "display_name", "identifier": "identifier", "translationKey": "translation_key", "validation_regex": "validation_regex"}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.exempt_handler()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_exempt_handler_required_params(self):
        """
        test_exempt_handler_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/types')
        mock_response = '[{"display_name": "display_name", "identifier": "identifier", "translationKey": "translation_key", "validation_regex": "validation_regex"}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.exempt_handler()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_exempt_handler_value_error(self):
        """
        test_exempt_handler_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exempt/types')
        mock_response = '[{"display_name": "display_name", "identifier": "identifier", "translationKey": "translation_key", "validation_regex": "validation_regex"}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.exempt_handler(**req_copy)



class TestListAccountExemptions():
    """
    Test Class for list_account_exemptions
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_list_account_exemptions_all_params(self):
        """
        list_account_exemptions()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/account')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.list_account_exemptions()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_account_exemptions_required_params(self):
        """
        test_list_account_exemptions_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/account')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.list_account_exemptions()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_account_exemptions_value_error(self):
        """
        test_list_account_exemptions_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/account')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.list_account_exemptions(**req_copy)



class TestExemptionsAccountDeleteHandler():
    """
    Test Class for exemptions_account_delete_handler
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_exemptions_account_delete_handler_all_params(self):
        """
        exemptions_account_delete_handler()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/deleteAll')
        mock_response = '{"number_of_exemptions_deleted": 28}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.exemptions_account_delete_handler()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_exemptions_account_delete_handler_required_params(self):
        """
        test_exemptions_account_delete_handler_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/deleteAll')
        mock_response = '{"number_of_exemptions_deleted": 28}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Invoke method
        response = service.exemptions_account_delete_handler()


        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_exemptions_account_delete_handler_value_error(self):
        """
        test_exemptions_account_delete_handler_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/deleteAll')
        mock_response = '{"number_of_exemptions_deleted": 28}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.exemptions_account_delete_handler(**req_copy)



class TestListImageExemptions():
    """
    Test Class for list_image_exemptions
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_list_image_exemptions_all_params(self):
        """
        list_image_exemptions()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'
        include_scope = True

        # Invoke method
        response = service.list_image_exemptions(
            resource,
            include_scope=include_scope,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?',1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'includeScope={}'.format('true' if include_scope else 'false') in query_string


    @responses.activate
    def test_list_image_exemptions_required_params(self):
        """
        test_list_image_exemptions_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'

        # Invoke method
        response = service.list_image_exemptions(
            resource,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200


    @responses.activate
    def test_list_image_exemptions_value_error(self):
        """
        test_list_image_exemptions_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/image/testString')
        mock_response = '[{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]'
        responses.add(responses.GET,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        resource = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "resource": resource,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.list_image_exemptions(**req_copy)



class TestListBulkImageExemptions():
    """
    Test Class for list_bulk_image_exemptions
    """

    def preprocess_url(self, request_url: str):
        """
        Preprocess the request URL to ensure the mock response will be found.
        """
        if re.fullmatch('.*/+', request_url) is None:
            return request_url
        else:
            return re.compile(request_url.rstrip('/') + '/+')

    @responses.activate
    def test_list_bulk_image_exemptions_all_params(self):
        """
        list_bulk_image_exemptions()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/images')
        mock_response = '{"mapKey": [{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        body = ['us.icr.io/birds/woodpecker:green', 'us.icr.io/birds/grebe:crested']

        # Invoke method
        response = service.list_bulk_image_exemptions(
            body,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body == body


    @responses.activate
    def test_list_bulk_image_exemptions_required_params(self):
        """
        test_list_bulk_image_exemptions_required_params()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/images')
        mock_response = '{"mapKey": [{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        body = ['us.icr.io/birds/woodpecker:green', 'us.icr.io/birds/grebe:crested']

        # Invoke method
        response = service.list_bulk_image_exemptions(
            body,
            headers={}
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body == body


    @responses.activate
    def test_list_bulk_image_exemptions_value_error(self):
        """
        test_list_bulk_image_exemptions_value_error()
        """
        # Set up mock
        url = self.preprocess_url(base_url + '/va/api/v3/exemptions/images')
        mock_response = '{"mapKey": [{"account_id": "account_id", "issue_id": "issue_id", "issue_type": "issue_type", "scope": {"scope_type": "scope_type", "namespace": "namespace", "repository": "repository", "tag": "tag"}}]}'
        responses.add(responses.POST,
                      url,
                      body=mock_response,
                      content_type='application/json',
                      status=200)

        # Set up parameter values
        body = ['us.icr.io/birds/woodpecker:green', 'us.icr.io/birds/grebe:crested']

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "body": body,
        }
        for param in req_param_dict.keys():
            req_copy = {key:val if key is not param else None for (key,val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                service.list_bulk_image_exemptions(**req_copy)



# endregion
##############################################################################
# End of Service: Exemption
##############################################################################


##############################################################################
# Start of Model Tests
##############################################################################
# region
class TestExemption():
    """
    Test Class for Exemption
    """

    def test_exemption_serialization(self):
        """
        Test serialization/deserialization for Exemption
        """

        # Construct dict forms of any model objects needed in order to build this model.

        exemption_scope_model = {} # ExemptionScope
        exemption_scope_model['scope_type'] = 'testString'
        exemption_scope_model['namespace'] = 'testString'
        exemption_scope_model['repository'] = 'testString'
        exemption_scope_model['tag'] = 'testString'

        # Construct a json representation of a Exemption model
        exemption_model_json = {}
        exemption_model_json['account_id'] = 'testString'
        exemption_model_json['issue_id'] = 'testString'
        exemption_model_json['issue_type'] = 'testString'
        exemption_model_json['scope'] = exemption_scope_model

        # Construct a model instance of Exemption by calling from_dict on the json representation
        exemption_model = Exemption.from_dict(exemption_model_json)
        assert exemption_model != False

        # Construct a model instance of Exemption by calling from_dict on the json representation
        exemption_model_dict = Exemption.from_dict(exemption_model_json).__dict__
        exemption_model2 = Exemption(**exemption_model_dict)

        # Verify the model instances are equivalent
        assert exemption_model == exemption_model2

        # Convert model instance back to dict and verify no loss of data
        exemption_model_json2 = exemption_model.to_dict()
        assert exemption_model_json2 == exemption_model_json

class TestExemptionScope():
    """
    Test Class for ExemptionScope
    """

    def test_exemption_scope_serialization(self):
        """
        Test serialization/deserialization for ExemptionScope
        """

        # Construct a json representation of a ExemptionScope model
        exemption_scope_model_json = {}
        exemption_scope_model_json['scope_type'] = 'testString'
        exemption_scope_model_json['namespace'] = 'testString'
        exemption_scope_model_json['repository'] = 'testString'
        exemption_scope_model_json['tag'] = 'testString'

        # Construct a model instance of ExemptionScope by calling from_dict on the json representation
        exemption_scope_model = ExemptionScope.from_dict(exemption_scope_model_json)
        assert exemption_scope_model != False

        # Construct a model instance of ExemptionScope by calling from_dict on the json representation
        exemption_scope_model_dict = ExemptionScope.from_dict(exemption_scope_model_json).__dict__
        exemption_scope_model2 = ExemptionScope(**exemption_scope_model_dict)

        # Verify the model instances are equivalent
        assert exemption_scope_model == exemption_scope_model2

        # Convert model instance back to dict and verify no loss of data
        exemption_scope_model_json2 = exemption_scope_model.to_dict()
        assert exemption_scope_model_json2 == exemption_scope_model_json

class TestScanReport():
    """
    Test Class for ScanReport
    """

    def test_scan_report_serialization(self):
        """
        Test serialization/deserialization for ScanReport
        """

        # Construct dict forms of any model objects needed in order to build this model.

        scanresult_configuration_issue_model = {} # ScanresultConfigurationIssue
        scanresult_configuration_issue_model['corrective_action'] = 'testString'
        scanresult_configuration_issue_model['description'] = 'testString'
        scanresult_configuration_issue_model['exempt'] = True
        scanresult_configuration_issue_model['meta'] = {}
        scanresult_configuration_issue_model['type'] = 'testString'

        scanresult_package_fixes_model = {} # ScanresultPackageFixes
        scanresult_package_fixes_model['corrective_action'] = 'testString'
        scanresult_package_fixes_model['description'] = 'testString'
        scanresult_package_fixes_model['fix_version'] = 'testString'
        scanresult_package_fixes_model['installed_version'] = 'testString'
        scanresult_package_fixes_model['package_name'] = 'testString'

        scanresult_security_notice_model = {} # ScanresultSecurityNotice
        scanresult_security_notice_model['notice'] = 'testString'
        scanresult_security_notice_model['notice_exempt'] = True
        scanresult_security_notice_model['notice_id'] = 'testString'
        scanresult_security_notice_model['summary'] = 'testString'
        scanresult_security_notice_model['vulnerable_packages'] = [scanresult_package_fixes_model]

        scanresult_cve_model = {} # ScanresultCVE
        scanresult_cve_model['cve_exempt'] = True
        scanresult_cve_model['cve_id'] = 'testString'
        scanresult_cve_model['exempt_security_notice_count'] = 38
        scanresult_cve_model['exempt_status'] = 'testString'
        scanresult_cve_model['security_notice_count'] = 38
        scanresult_cve_model['security_notices'] = [scanresult_security_notice_model]
        scanresult_cve_model['summary'] = 'testString'
        scanresult_cve_model['total_security_notice_count'] = 38

        # Construct a json representation of a ScanReport model
        scan_report_model_json = {}
        scan_report_model_json['configuration_issues'] = [scanresult_configuration_issue_model]
        scan_report_model_json['id'] = 'testString'
        scan_report_model_json['scan_time'] = 26
        scan_report_model_json['status'] = 'testString'
        scan_report_model_json['vulnerabilities'] = [scanresult_cve_model]

        # Construct a model instance of ScanReport by calling from_dict on the json representation
        scan_report_model = ScanReport.from_dict(scan_report_model_json)
        assert scan_report_model != False

        # Construct a model instance of ScanReport by calling from_dict on the json representation
        scan_report_model_dict = ScanReport.from_dict(scan_report_model_json).__dict__
        scan_report_model2 = ScanReport(**scan_report_model_dict)

        # Verify the model instances are equivalent
        assert scan_report_model == scan_report_model2

        # Convert model instance back to dict and verify no loss of data
        scan_report_model_json2 = scan_report_model.to_dict()
        assert scan_report_model_json2 == scan_report_model_json

class TestScanReportList():
    """
    Test Class for ScanReportList
    """

    def test_scan_report_list_serialization(self):
        """
        Test serialization/deserialization for ScanReportList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        scanresult_configuration_issue_model = {} # ScanresultConfigurationIssue
        scanresult_configuration_issue_model['corrective_action'] = 'testString'
        scanresult_configuration_issue_model['description'] = 'testString'
        scanresult_configuration_issue_model['exempt'] = True
        scanresult_configuration_issue_model['meta'] = {}
        scanresult_configuration_issue_model['type'] = 'testString'

        scanresult_package_fixes_model = {} # ScanresultPackageFixes
        scanresult_package_fixes_model['corrective_action'] = 'testString'
        scanresult_package_fixes_model['description'] = 'testString'
        scanresult_package_fixes_model['fix_version'] = 'testString'
        scanresult_package_fixes_model['installed_version'] = 'testString'
        scanresult_package_fixes_model['package_name'] = 'testString'

        scanresult_security_notice_model = {} # ScanresultSecurityNotice
        scanresult_security_notice_model['notice'] = 'testString'
        scanresult_security_notice_model['notice_exempt'] = True
        scanresult_security_notice_model['notice_id'] = 'testString'
        scanresult_security_notice_model['summary'] = 'testString'
        scanresult_security_notice_model['vulnerable_packages'] = [scanresult_package_fixes_model]

        scanresult_cve_model = {} # ScanresultCVE
        scanresult_cve_model['cve_exempt'] = True
        scanresult_cve_model['cve_id'] = 'testString'
        scanresult_cve_model['exempt_security_notice_count'] = 38
        scanresult_cve_model['exempt_status'] = 'testString'
        scanresult_cve_model['security_notice_count'] = 38
        scanresult_cve_model['security_notices'] = [scanresult_security_notice_model]
        scanresult_cve_model['summary'] = 'testString'
        scanresult_cve_model['total_security_notice_count'] = 38

        scan_report_model = {} # ScanReport
        scan_report_model['configuration_issues'] = [scanresult_configuration_issue_model]
        scan_report_model['id'] = 'testString'
        scan_report_model['scan_time'] = 26
        scan_report_model['status'] = 'testString'
        scan_report_model['vulnerabilities'] = [scanresult_cve_model]

        # Construct a json representation of a ScanReportList model
        scan_report_list_model_json = {}
        scan_report_list_model_json['assessments'] = {}

        # Construct a model instance of ScanReportList by calling from_dict on the json representation
        scan_report_list_model = ScanReportList.from_dict(scan_report_list_model_json)
        assert scan_report_list_model != False

        # Construct a model instance of ScanReportList by calling from_dict on the json representation
        scan_report_list_model_dict = ScanReportList.from_dict(scan_report_list_model_json).__dict__
        scan_report_list_model2 = ScanReportList(**scan_report_list_model_dict)

        # Verify the model instances are equivalent
        assert scan_report_list_model == scan_report_list_model2

        # Convert model instance back to dict and verify no loss of data
        scan_report_list_model_json2 = scan_report_list_model.to_dict()
        assert scan_report_list_model_json2 == scan_report_list_model_json

class TestExemptionDeletionInfo():
    """
    Test Class for ExemptionDeletionInfo
    """

    def test_exemption_deletion_info_serialization(self):
        """
        Test serialization/deserialization for ExemptionDeletionInfo
        """

        # Construct a json representation of a ExemptionDeletionInfo model
        exemption_deletion_info_model_json = {}
        exemption_deletion_info_model_json['number_of_exemptions_deleted'] = 38

        # Construct a model instance of ExemptionDeletionInfo by calling from_dict on the json representation
        exemption_deletion_info_model = ExemptionDeletionInfo.from_dict(exemption_deletion_info_model_json)
        assert exemption_deletion_info_model != False

        # Construct a model instance of ExemptionDeletionInfo by calling from_dict on the json representation
        exemption_deletion_info_model_dict = ExemptionDeletionInfo.from_dict(exemption_deletion_info_model_json).__dict__
        exemption_deletion_info_model2 = ExemptionDeletionInfo(**exemption_deletion_info_model_dict)

        # Verify the model instances are equivalent
        assert exemption_deletion_info_model == exemption_deletion_info_model2

        # Convert model instance back to dict and verify no loss of data
        exemption_deletion_info_model_json2 = exemption_deletion_info_model.to_dict()
        assert exemption_deletion_info_model_json2 == exemption_deletion_info_model_json

class TestExemptionTypeInfo():
    """
    Test Class for ExemptionTypeInfo
    """

    def test_exemption_type_info_serialization(self):
        """
        Test serialization/deserialization for ExemptionTypeInfo
        """

        # Construct a json representation of a ExemptionTypeInfo model
        exemption_type_info_model_json = {}
        exemption_type_info_model_json['display_name'] = 'testString'
        exemption_type_info_model_json['identifier'] = 'testString'
        exemption_type_info_model_json['translationKey'] = 'testString'
        exemption_type_info_model_json['validation_regex'] = 'testString'

        # Construct a model instance of ExemptionTypeInfo by calling from_dict on the json representation
        exemption_type_info_model = ExemptionTypeInfo.from_dict(exemption_type_info_model_json)
        assert exemption_type_info_model != False

        # Construct a model instance of ExemptionTypeInfo by calling from_dict on the json representation
        exemption_type_info_model_dict = ExemptionTypeInfo.from_dict(exemption_type_info_model_json).__dict__
        exemption_type_info_model2 = ExemptionTypeInfo(**exemption_type_info_model_dict)

        # Verify the model instances are equivalent
        assert exemption_type_info_model == exemption_type_info_model2

        # Convert model instance back to dict and verify no loss of data
        exemption_type_info_model_json2 = exemption_type_info_model.to_dict()
        assert exemption_type_info_model_json2 == exemption_type_info_model_json

class TestScanreportImageSummary():
    """
    Test Class for ScanreportImageSummary
    """

    def test_scanreport_image_summary_serialization(self):
        """
        Test serialization/deserialization for ScanreportImageSummary
        """

        # Construct a json representation of a ScanreportImageSummary model
        scanreport_image_summary_model_json = {}
        scanreport_image_summary_model_json['configuration_issue_count'] = 38
        scanreport_image_summary_model_json['created_time'] = 26
        scanreport_image_summary_model_json['exempt_configuration_issue_count'] = 38
        scanreport_image_summary_model_json['exempt_issue_count'] = 38
        scanreport_image_summary_model_json['exempt_vulnerability_count'] = 38
        scanreport_image_summary_model_json['issue_count'] = 38
        scanreport_image_summary_model_json['name'] = 'testString'
        scanreport_image_summary_model_json['scan_time'] = 26
        scanreport_image_summary_model_json['status'] = 'testString'
        scanreport_image_summary_model_json['vulnerability_count'] = 38

        # Construct a model instance of ScanreportImageSummary by calling from_dict on the json representation
        scanreport_image_summary_model = ScanreportImageSummary.from_dict(scanreport_image_summary_model_json)
        assert scanreport_image_summary_model != False

        # Construct a model instance of ScanreportImageSummary by calling from_dict on the json representation
        scanreport_image_summary_model_dict = ScanreportImageSummary.from_dict(scanreport_image_summary_model_json).__dict__
        scanreport_image_summary_model2 = ScanreportImageSummary(**scanreport_image_summary_model_dict)

        # Verify the model instances are equivalent
        assert scanreport_image_summary_model == scanreport_image_summary_model2

        # Convert model instance back to dict and verify no loss of data
        scanreport_image_summary_model_json2 = scanreport_image_summary_model.to_dict()
        assert scanreport_image_summary_model_json2 == scanreport_image_summary_model_json

class TestScanreportImageSummaryList():
    """
    Test Class for ScanreportImageSummaryList
    """

    def test_scanreport_image_summary_list_serialization(self):
        """
        Test serialization/deserialization for ScanreportImageSummaryList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        scanreport_image_summary_model = {} # ScanreportImageSummary
        scanreport_image_summary_model['configuration_issue_count'] = 38
        scanreport_image_summary_model['created_time'] = 26
        scanreport_image_summary_model['exempt_configuration_issue_count'] = 38
        scanreport_image_summary_model['exempt_issue_count'] = 38
        scanreport_image_summary_model['exempt_vulnerability_count'] = 38
        scanreport_image_summary_model['issue_count'] = 38
        scanreport_image_summary_model['name'] = 'testString'
        scanreport_image_summary_model['scan_time'] = 26
        scanreport_image_summary_model['status'] = 'testString'
        scanreport_image_summary_model['vulnerability_count'] = 38

        # Construct a json representation of a ScanreportImageSummaryList model
        scanreport_image_summary_list_model_json = {}
        scanreport_image_summary_list_model_json['images'] = [scanreport_image_summary_model]

        # Construct a model instance of ScanreportImageSummaryList by calling from_dict on the json representation
        scanreport_image_summary_list_model = ScanreportImageSummaryList.from_dict(scanreport_image_summary_list_model_json)
        assert scanreport_image_summary_list_model != False

        # Construct a model instance of ScanreportImageSummaryList by calling from_dict on the json representation
        scanreport_image_summary_list_model_dict = ScanreportImageSummaryList.from_dict(scanreport_image_summary_list_model_json).__dict__
        scanreport_image_summary_list_model2 = ScanreportImageSummaryList(**scanreport_image_summary_list_model_dict)

        # Verify the model instances are equivalent
        assert scanreport_image_summary_list_model == scanreport_image_summary_list_model2

        # Convert model instance back to dict and verify no loss of data
        scanreport_image_summary_list_model_json2 = scanreport_image_summary_list_model.to_dict()
        assert scanreport_image_summary_list_model_json2 == scanreport_image_summary_list_model_json

class TestScanreportSummary():
    """
    Test Class for ScanreportSummary
    """

    def test_scanreport_summary_serialization(self):
        """
        Test serialization/deserialization for ScanreportSummary
        """

        # Construct a json representation of a ScanreportSummary model
        scanreport_summary_model_json = {}
        scanreport_summary_model_json['configuration_issue_count'] = 38
        scanreport_summary_model_json['exempt_configuration_issue_count'] = 38
        scanreport_summary_model_json['exempt_issue_count'] = 38
        scanreport_summary_model_json['exempt_vulnerability_count'] = 38
        scanreport_summary_model_json['issue_count'] = 38
        scanreport_summary_model_json['scan_time'] = 26
        scanreport_summary_model_json['status'] = 'testString'
        scanreport_summary_model_json['vulnerability_count'] = 38

        # Construct a model instance of ScanreportSummary by calling from_dict on the json representation
        scanreport_summary_model = ScanreportSummary.from_dict(scanreport_summary_model_json)
        assert scanreport_summary_model != False

        # Construct a model instance of ScanreportSummary by calling from_dict on the json representation
        scanreport_summary_model_dict = ScanreportSummary.from_dict(scanreport_summary_model_json).__dict__
        scanreport_summary_model2 = ScanreportSummary(**scanreport_summary_model_dict)

        # Verify the model instances are equivalent
        assert scanreport_summary_model == scanreport_summary_model2

        # Convert model instance back to dict and verify no loss of data
        scanreport_summary_model_json2 = scanreport_summary_model.to_dict()
        assert scanreport_summary_model_json2 == scanreport_summary_model_json

class TestScanresultCVE():
    """
    Test Class for ScanresultCVE
    """

    def test_scanresult_cve_serialization(self):
        """
        Test serialization/deserialization for ScanresultCVE
        """

        # Construct dict forms of any model objects needed in order to build this model.

        scanresult_package_fixes_model = {} # ScanresultPackageFixes
        scanresult_package_fixes_model['corrective_action'] = 'testString'
        scanresult_package_fixes_model['description'] = 'testString'
        scanresult_package_fixes_model['fix_version'] = 'testString'
        scanresult_package_fixes_model['installed_version'] = 'testString'
        scanresult_package_fixes_model['package_name'] = 'testString'

        scanresult_security_notice_model = {} # ScanresultSecurityNotice
        scanresult_security_notice_model['notice'] = 'testString'
        scanresult_security_notice_model['notice_exempt'] = True
        scanresult_security_notice_model['notice_id'] = 'testString'
        scanresult_security_notice_model['summary'] = 'testString'
        scanresult_security_notice_model['vulnerable_packages'] = [scanresult_package_fixes_model]

        # Construct a json representation of a ScanresultCVE model
        scanresult_cve_model_json = {}
        scanresult_cve_model_json['cve_exempt'] = True
        scanresult_cve_model_json['cve_id'] = 'testString'
        scanresult_cve_model_json['exempt_security_notice_count'] = 38
        scanresult_cve_model_json['exempt_status'] = 'testString'
        scanresult_cve_model_json['security_notice_count'] = 38
        scanresult_cve_model_json['security_notices'] = [scanresult_security_notice_model]
        scanresult_cve_model_json['summary'] = 'testString'
        scanresult_cve_model_json['total_security_notice_count'] = 38

        # Construct a model instance of ScanresultCVE by calling from_dict on the json representation
        scanresult_cve_model = ScanresultCVE.from_dict(scanresult_cve_model_json)
        assert scanresult_cve_model != False

        # Construct a model instance of ScanresultCVE by calling from_dict on the json representation
        scanresult_cve_model_dict = ScanresultCVE.from_dict(scanresult_cve_model_json).__dict__
        scanresult_cve_model2 = ScanresultCVE(**scanresult_cve_model_dict)

        # Verify the model instances are equivalent
        assert scanresult_cve_model == scanresult_cve_model2

        # Convert model instance back to dict and verify no loss of data
        scanresult_cve_model_json2 = scanresult_cve_model.to_dict()
        assert scanresult_cve_model_json2 == scanresult_cve_model_json

class TestScanresultConfigurationIssue():
    """
    Test Class for ScanresultConfigurationIssue
    """

    def test_scanresult_configuration_issue_serialization(self):
        """
        Test serialization/deserialization for ScanresultConfigurationIssue
        """

        # Construct a json representation of a ScanresultConfigurationIssue model
        scanresult_configuration_issue_model_json = {}
        scanresult_configuration_issue_model_json['corrective_action'] = 'testString'
        scanresult_configuration_issue_model_json['description'] = 'testString'
        scanresult_configuration_issue_model_json['exempt'] = True
        scanresult_configuration_issue_model_json['meta'] = {}
        scanresult_configuration_issue_model_json['type'] = 'testString'

        # Construct a model instance of ScanresultConfigurationIssue by calling from_dict on the json representation
        scanresult_configuration_issue_model = ScanresultConfigurationIssue.from_dict(scanresult_configuration_issue_model_json)
        assert scanresult_configuration_issue_model != False

        # Construct a model instance of ScanresultConfigurationIssue by calling from_dict on the json representation
        scanresult_configuration_issue_model_dict = ScanresultConfigurationIssue.from_dict(scanresult_configuration_issue_model_json).__dict__
        scanresult_configuration_issue_model2 = ScanresultConfigurationIssue(**scanresult_configuration_issue_model_dict)

        # Verify the model instances are equivalent
        assert scanresult_configuration_issue_model == scanresult_configuration_issue_model2

        # Convert model instance back to dict and verify no loss of data
        scanresult_configuration_issue_model_json2 = scanresult_configuration_issue_model.to_dict()
        assert scanresult_configuration_issue_model_json2 == scanresult_configuration_issue_model_json

class TestScanresultPackageFixes():
    """
    Test Class for ScanresultPackageFixes
    """

    def test_scanresult_package_fixes_serialization(self):
        """
        Test serialization/deserialization for ScanresultPackageFixes
        """

        # Construct a json representation of a ScanresultPackageFixes model
        scanresult_package_fixes_model_json = {}
        scanresult_package_fixes_model_json['corrective_action'] = 'testString'
        scanresult_package_fixes_model_json['description'] = 'testString'
        scanresult_package_fixes_model_json['fix_version'] = 'testString'
        scanresult_package_fixes_model_json['installed_version'] = 'testString'
        scanresult_package_fixes_model_json['package_name'] = 'testString'

        # Construct a model instance of ScanresultPackageFixes by calling from_dict on the json representation
        scanresult_package_fixes_model = ScanresultPackageFixes.from_dict(scanresult_package_fixes_model_json)
        assert scanresult_package_fixes_model != False

        # Construct a model instance of ScanresultPackageFixes by calling from_dict on the json representation
        scanresult_package_fixes_model_dict = ScanresultPackageFixes.from_dict(scanresult_package_fixes_model_json).__dict__
        scanresult_package_fixes_model2 = ScanresultPackageFixes(**scanresult_package_fixes_model_dict)

        # Verify the model instances are equivalent
        assert scanresult_package_fixes_model == scanresult_package_fixes_model2

        # Convert model instance back to dict and verify no loss of data
        scanresult_package_fixes_model_json2 = scanresult_package_fixes_model.to_dict()
        assert scanresult_package_fixes_model_json2 == scanresult_package_fixes_model_json

class TestScanresultSecurityNotice():
    """
    Test Class for ScanresultSecurityNotice
    """

    def test_scanresult_security_notice_serialization(self):
        """
        Test serialization/deserialization for ScanresultSecurityNotice
        """

        # Construct dict forms of any model objects needed in order to build this model.

        scanresult_package_fixes_model = {} # ScanresultPackageFixes
        scanresult_package_fixes_model['corrective_action'] = 'testString'
        scanresult_package_fixes_model['description'] = 'testString'
        scanresult_package_fixes_model['fix_version'] = 'testString'
        scanresult_package_fixes_model['installed_version'] = 'testString'
        scanresult_package_fixes_model['package_name'] = 'testString'

        # Construct a json representation of a ScanresultSecurityNotice model
        scanresult_security_notice_model_json = {}
        scanresult_security_notice_model_json['notice'] = 'testString'
        scanresult_security_notice_model_json['notice_exempt'] = True
        scanresult_security_notice_model_json['notice_id'] = 'testString'
        scanresult_security_notice_model_json['summary'] = 'testString'
        scanresult_security_notice_model_json['vulnerable_packages'] = [scanresult_package_fixes_model]

        # Construct a model instance of ScanresultSecurityNotice by calling from_dict on the json representation
        scanresult_security_notice_model = ScanresultSecurityNotice.from_dict(scanresult_security_notice_model_json)
        assert scanresult_security_notice_model != False

        # Construct a model instance of ScanresultSecurityNotice by calling from_dict on the json representation
        scanresult_security_notice_model_dict = ScanresultSecurityNotice.from_dict(scanresult_security_notice_model_json).__dict__
        scanresult_security_notice_model2 = ScanresultSecurityNotice(**scanresult_security_notice_model_dict)

        # Verify the model instances are equivalent
        assert scanresult_security_notice_model == scanresult_security_notice_model2

        # Convert model instance back to dict and verify no loss of data
        scanresult_security_notice_model_json2 = scanresult_security_notice_model.to_dict()
        assert scanresult_security_notice_model_json2 == scanresult_security_notice_model_json


# endregion
##############################################################################
# End of Model Tests
##############################################################################
